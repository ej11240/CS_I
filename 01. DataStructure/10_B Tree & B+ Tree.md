# B Tree

> 이진트리의 확장 버전으로, **더 많은 수의 자식**을 가질 수 있게 일반화 시킨 트리구조
> 모든 leaf노드들이 같은 레벨을 가질 수 있도록 자동으로 균형을 맞춘다. 

<br>

* 정렬된 순서를 보장, 멀티레벨 인덱싱을 통한 빠른 검색 -> 데이터베이스와 파일 시스템에서 널리 사용된다.  
  
![image](https://user-images.githubusercontent.com/65678579/157381727-32037321-e6ba-4e18-bdb8-224a8405cef0.png) 
> 멀티레벨 인덱싱  

 대량의 데이터를 처리해야 할 때, 하나의 노드에 많은 데이터를 가질 수 있어 효율적이다.  

 대량의 데이터는 메모리보다 블럭 단위로 입출력하는 하드디스크 또는 SSD에 저장해야하기 때문이다.  

만약 한 블럭이 1024 바이트일 경우, 2바이트를 읽거나 1024바이트를 읽는 경우 모두 똑같은 입출력 비용이 발생하므로 1024바이트를 모두 채우면 입출력에 효율적인 구성을 갖출 수 있다.  


* 최대 M개의 자식을 가질 수 있는 B Tree를 M차 B Tree라고 한다.  

<br>

## 규칙
* 노드는 최대 M개 부터 M/2개 까지의 자식을 가질 수 있다.
* 노드에는 최대 M-1 개부터 [M/2]-1 개의 키가 포함될 수 있다.
* 노드의 키가 x개라면 자식의 수는 x+1개다.
* 최소차수는 자식 수의 하한값을 의미한다. 최소차수가 t라면 M = 2t-1을 만족한다.

EX. 최소차수 t가 2라면, 3차 B트리이며, key의 하한은 1개이다.

<br>

### 3차 B Tree  
![image](https://user-images.githubusercontent.com/65678579/157383610-c53d0434-e855-47a7-98ed-cb6027dfb08e.png)


### 탐색
루트노드에서 시작하여 하향식으로 검색한다.  

1. 루트 노드에서 시작하여 key를 순회  
    - 만약 k와 같은 key를 찾았다면 검색을 종료  
    - 검색하는 값과 key들의 대소관계를 비교한다. 
    - 어떤 key들 사이에 k가 들어간다면 해당 key들 사이의 자식노드로 내려감.  
2. leaf 노드에 도달할 때 까지 반복한다. 리프노드에도 k와 같은 key가 없다면 탐색에 실패한다.

<br>

### 삽입
1. 분할이 일어나지 않는 경우
    - 키 값에 따라 알맞은 위치에 삽입한다.
2. 분할이 일어나는 경우
    - 노드가 담을 수 있는 최대 key 개수를 초과하는 경우 발생
    - 왼쪽 키들은 왼쪽 자식으로, 오른쪽 키들은 오른쪽 자식으로 분할
    - 만약 부모 노드 역시 가득 차게 되면, 부모노드에서도 이 과정을 반복
<br>

### 삭제
1. 삭제할 key k가 leaf노드에 존재하는 경우
    - 다른 노드에 영향을 주지 않으므로 단순 삭제
2.  현재 노드의 key 개수가 최소 key 개수보다 큰 경우
    - 다른 노드에 영향을 주지 않으므로 단순 삭제
3. 왼쪽 또는 오른쪽 형제 노드의 key가 최소 key 개수 이상인 경우
    - 부모 key 값을 자식으로 변경
    - 최소 키 개수 이상의 키를 가진 형제 노드가 왼쪽 형제라면 가장 큰 값을, 오른쪽 형제라면 가장 작은 값을 부모 key로 대체
4. 삭제할 key k 가 내부 노드에 있고, 노드와 노드 자식의 key가 모두 최소개인 경우
![image](https://user-images.githubusercontent.com/65678579/157386736-c660bbfc-15f3-4c12-ac7d-b13c7400a5a6.png)


--------------------


# B+ Tree
> B Tree의 변형 구조로, index 부분과 leaf 노드로 구성된 순차 데이터 부분으로 이루어짐. index 부분의 key 값은 leaf에 있는 key 값을 직접 찾아가는데 사용

## 규칙
* B Tree와 같음
![image](https://user-images.githubusercontent.com/65678579/157387753-eeacd999-4169-4015-9171-706204bdda6a.png)
> B+ Tree 예시

### 장점
* 블럭 사이즈를 더 많이 이용할 수 있다.(Key 값에 대한 하드디스크 엑세스 주소가 없기 때문)
* leaf 노드끼리 연결리스트로 연결되어 있어서 범위 탐색에 매우 유리

### 단점
* B Tree의 경우 최상 케이스에서는 루트에서 끝날 수 있지만, B+ Tree는 무조건 leaf노드까지 내려가봐야 함

<br>

---------

### B Tree & B+ Tree
> B Tree는 각 노드에 데이터가 저장
> B+ Tree는 index노드와 leaf노드로 분리되어 저장(또한, leaf노드는 서로 연결되어 있어서 임의접근이나 순차접근 모두 성능이 우수함)

* B Tree는 각 노드에 key와 data가 모두 들어가며, data는 disk block으로 포인터가 될 수 있다.
* B+ Tree는 각 노드에서 key만 들어가고 data는 모두 leaf노드에만 존재 -> 삽입, 삭제 모두 leaf노드에서 이뤄짐

----------


🔗참고링크
[Link](https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Plus-Tree)

