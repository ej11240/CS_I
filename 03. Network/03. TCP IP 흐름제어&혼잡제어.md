### TCP/IP 흐름제어 & 혼잡제어

⭐  **TCP/IP란?**

- Transmission Control Protocol/Internet Protocol의 약자
- 4계층인 **전송계층(Transport Layer)**에 속하는 중요 프로토콜
- IP 주소체계를 따르고 IP Routing을 이용해 목적지에 도달하며 TCP의 특성을 활용해 논리적 연결을 생성하며 신뢰성을 유지하겠다는 규약
- 네트워크 망에 연결된 컴퓨터의 데이터를 전송할 때 순서대로, 에러 없이 교환할 수 있게 하는 역할
- **즉, 데이터가 빠지지 않고 전달되었는지 꼼꼼하게 챙기는 것**
- IP는 목적지를 찾아가도록 하는 역할, TCP는 데이터를 빠트리지 않고 목적지까지 잘 전달해주는 역할


⭐  **TCP 프로토콜의 특징**

    1️⃣ 연결 지향 프로토콜 (Connection oriented protocol)

    - 물리적으로 전용회선이 연결되어 있는 것처럼 가상의 연결통로를 설정하여 통신하는 방식 ****(가상회선방식)
        - **가상회선방식** : 물리적으로 전용회선이 연결되어 있는 것처럼 논리적으로 동작하는 방식
    - 논리적인 통로를 통해 데이터를 주고 받음으로써 데이터의 전송 순서를 보장
    - 스트림 기반의 전송 방식 사용
    - 데이터를 임의의 크기로 나누어 연속해서 전송하는 방식 사용

    2️⃣ 신뢰할 수 있는 프로토콜(Reliable Protocol)

    - 흐름제어
        - 송신 측과 수신 측의 데이터 처리 속도 차이를 해결하기 위한 방법
        - 상대방이 받을 수 있을 만큼만의 데이터(packet)를 효율적으로 전송하는 것
        - **슬라이딩 윈도우(Sliding Window) 방식** : 상대방이 수신 가능한 크기(Window size) 내에서 데이터를 연속해서 전송하는 방식으로 매 세그먼트 (Segment) 전송 시마다 수신 확인 응답을 수신한 후 전송
    - 혼잡제어
        - 송신 측의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하기 위한 방법
        - 네트워크의 혼잡 정도에 따라 송신자가 데이터 전송량을 제어 가능
        - 혼잡 정도에 대한 판단 기준은 데이터의 손실 발생 유무로 판단
        - TCP 혼잡 제어 알고리즘 (network congestion avoidance algorithm) 사용
    - 오류제어
        - 데이터의 오류나 누락 없이 안전한 전송 보장
        - 오류 또는 누락 발생 시 재전송을 수행하여 이를 보정
    - 문제점
        - 손실 : 패킷이 손실될 수 있는 문제
        - 순서 바뀜 : 패킷의 순서가 바뀌는 문제
        - Congestion : 네트워크가 혼잡해지는 문제
        - Overload : 송신할 때 overload 되는 문제
        
        
⭐ **TCP 프로토콜 전송 과정**

1. 응용 계층 (Application layer)에서는 실제 데이터를 넘기며, 데이터를 인코딩하고 수신자와 통신할 준비를 한다.
2. 전송 계층 (Transport layer)에서는 상위 계층의 데이터에 TCP 헤더를 붙인다. 
    
    데이터의 크기가 크면 MTU 단위로 데이터를 쪼개는데, 이를 세그먼트 (TCP가 실을 수 있는 데이터의 단위) 라고 한다.
    
    이후 네트워크 계층 (Network layer)으로 넘긴다. 
    
3. 이후 아래에서 receiving node로 전송이 된다.
    
    이때, sender의 send buffer에 data를 저장하고, receiver는 receive buffer에 data를 저장한다.
    
4. Application에서 준비가 되면 이 buffer에 있는 것을 읽는다.
    
    즉, flow control의 핵심은 이 receiver buffer가 넘치지 않게 하는 것이다.
    
5. receiver는 RWND (Receive Window) : receive buffer의 남은 공간을 알린다. 


⭐ **흐름 제어 (Flow Control)**

- 배경
    - 데이터 전달 시 수신보다 송신 측의 속도가 빠를 경우에 문제 발생
    - 수신 측에서 제한한 저장 용량을 초과한 이후에 도착하는 데이터는 손실될 수 있으며, 만약 손실된다면 불필요한 추가 패킷 전송 발생
    - 이러한 위험을 줄이기 위해 송신 측의 데이터 전송량을 수신 측에 따라 조절해야 하는 필요성 증가
- 개념
    - 송신 측과 수신 측의 TCP 버퍼 크기 차이로 인해 생기는 데이터 처리 속도 차이를 해결하기 위한 기법
    - 송신 측은 버퍼에 TCP 세그먼트를 보관한 후 순차적으로 전송하고, 수신 측은 도착한 TCP 세그먼트를 Application이 읽을 때까지 버퍼에 보관
    - 즉, 송신과 수신 사이의 패킷 수를 제어하는 기능
- 방법
    
    💙 ***Stop and Wait***
    
    - 매번 전송한 패킷에 대해 확인 응답(ACK)를 받으면 다음 패킷을 전송하는 방법
    - 패킷을 하나씩 보내기 때문에 비효율적
    
    ![1](https://user-images.githubusercontent.com/61955796/159539937-7ae6e918-4ef0-4819-8724-f5562c719a61.png)
    
    💙 ***Sliding Window***
    
    - 수신 측에서 설정한 윈도우 크기만큼 송신 측에서 확인 응답(ACK) 없이 패킷을 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 방법
    - 윈도우 크기란?
        - 최초의 윈도우 크기는 호스트들의 '3 way handshaking'을 통해 수신 측 윈도우 크기로 설정되며, 이후 수신 측의 버퍼에 남아있는 공간에 따라 변한다.
        - 윈도우 크기는 수신 측에서 송신 측으로 확인 응답(ACK)을 보낼 때 TCP 헤더(window size)에 담아서 보낸다.
        - 즉, 윈도우는 메모리 버퍼의 일정 영역이라고 생각하면 된다.
    - 동작 방식
        - 윈도우에 포함된 패킷을 계속 전송하고, 수신 측으로부터 확인 응답(ACK)이 오면 윈도우를 옆으로 옮겨 다음 패킷들을 전송
        
        ![2](https://user-images.githubusercontent.com/61955796/159539965-f02bf0ba-7d30-49b2-9e68-cb75229264d9.png)
        
        - 수신자는 최초 윈도우 사이즈를 7로 설정
        - 송신자는 수신자의 확인 응답(ACK)을 받기 전까지 데이터를 계속 보냄
        - 수신자는 확인 응답(ACK)을 송신자에게 보내면, 슬라이딩 윈도우 사이즈을 충족할 수 있게끔 윈도우를 옆으로 옮김
        - 이후 데이터를 다 받을 때까지 위 과정을 반복
    - 재전송
        - 송신 측은 일정 시간 동안 수신 측으로부터 확인 응답(ACK)을 받지 못하면, 패킷을 재전송
        - 만약, 송신 측에서 재전송을 했는데 패킷이 소실된 경우가 아니라 수신 측의 버퍼에 남는 공간 없는 경우면 문제가 발생
        - 이를 해결하기 위해 송신 측은 해결 응답(ACK)을 보내면서 남은 버퍼의 크기 (윈도우 크기)도 함께 전송
    - 예시
        
        1️⃣ 송신 버퍼
        
        ![3](https://user-images.githubusercontent.com/61955796/159539995-5a3b08bc-e524-4b7e-847d-6e20130c10bd.png)
        
        - 200 이전의 바이트: 이미 전송됐고 확인 응답을 받은 상태
        - 200 ~ 202 바이트: 전송되었으나 확인 응답을 받지 못한 상태
        - 203 ~ 211 바이트: 아직 전송이 되지 않은 상태
        
        2️⃣ 수신 윈도우
        
        ![4](https://user-images.githubusercontent.com/61955796/159540023-b47817b9-3b82-4425-b3cb-b364d9ecebfd.png)
        
        3️⃣ 송신 윈도우
        
        - 수신 윈도우보다 작거나 같은 크기로 송신 윈도우를 설정하게 되면 흐름제어 가능
        
        ![5](https://user-images.githubusercontent.com/61955796/159540051-0fa90a0c-332a-464c-8d8b-cd9551897611.png)
        
        4️⃣ 송신 윈도우 이동
        
        ![6](https://user-images.githubusercontent.com/61955796/159540090-84dee499-03cb-4a36-a141-89a433f7c767.png)
        
        5️⃣ 결과
        
        - Before : 203 ~ 204를 전송하면 수신 측에서는 확인 응답 203을 보내고, 송신측은 이를 받아 After 상태와 같이 수신 윈도우를 203 ~ 209 범위로 이동
        - After : 205 ~ 209 전송 가능


⭐ 혼잡 제어 (Congestion Control)

- 배경
    - 데이터의 양이 라우터가 처리할 수 있는 양을 초과하면 초과된 데이터 처리 불가
    - 이때 송신 측에서는 라우터가 처리하지 못한 데이터를 손실 데이터로 간주하고 계속 재전송하여 네트워크를 혼잡하게 만듦
    - 이런 상황은 송신 측의 전송 속도를 적절히 조절하여 예방 가능
- 개념
    - 네트워크 내의 패킷 수를 조절하여 네트워크의 오버플로우를 방지하는 기능
- 방법
    
    💙 *****AIMD (Additive Increse/Multicative Decrease)*****
    
    - 합 증가/곱 감소 방식
    - 처음에 패킷을 하나씩 보내고 문제 없이 도착하면 윈도우의 크기를 1씩 증가시켜가며 전송
    - 전송에 실패하면 윈도우 크기를 반으로 줄임
    - 윈도우 크기를 너무 조금씩 늘리기 때문에 네트워크의 모든 대역을 활용하여 제대로 된 속도로 통신하기까지 시간이 오래 걸린다는 단점
    
    ![7](https://user-images.githubusercontent.com/61955796/159540119-cc69f976-b461-468a-86b8-809de2b94b54.png)
    
    💙 ***Slow Start***
    
    - 윈도우의 크기를 1, 2, 4, 8, ...과 같이 지수적으로 증가시키다가 혼잡이 감지되면 윈도우 크기를 1로 줄이는 방식
    - 보낸 데이터의 ACK가 도착할 때마다 윈도우 크기를 증가시키기 때문에 처음에는 윈도우 크기가 조금 느리게 증가할지라도, 시간이 가면 갈수록 윈도우 크기가 점점 빠르게 증가한다는 장점
    
    💙 *****Fast Retransmit (빠른 재전송)*****
    
    - 세그먼트로 분할된 내용들이 순서대로 도착하지 않는 경우가 발생했을 때 사용
    - 수신 측에서는 순서대로 잘 도착한 마지막 패킷의 다음 순번을 ACK 패킷에 실어서 보내고 송신 측에서 이런 중복 ACK를 3개 받으면 재전송 시작
    - 송신 측은 자신이 설정한 타임 아웃 시간이 지나지 않았어도 바로 해당 패킷을 재전송할 수 있기 때문에 보다 빠른 재전송률을 유지
    
    💙 ***Fast Recovery (빠른 회복)***
    
    - 혼잡한 상태가 되면 윈도우 크기를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방법
    - 혼잡상황을 겪고 난 이후에는 AMID 방식 사용
    

출처

[https://steady-coding.tistory.com/507](https://steady-coding.tistory.com/507)

[https://aws-hyoh.tistory.com/entry/TCPIP-쉽게-이해하기](https://aws-hyoh.tistory.com/entry/TCPIP-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)

[https://itragdoll.tistory.com/57](https://itragdoll.tistory.com/57)
