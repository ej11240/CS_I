## **Monolithic vs MSA**

소프트웨어 개발 기법

### **Monolithic Architecture**

'한 덩어리'에 해당하는 구조로 구성. 모든 기능을 하나의 어플리케이션에서 비즈니스 로직을 구성해 운영

장점: 개발이나 환경설정이 간단. → 작은 사이즈의 프로젝트에서 유리

- 하나의 프로세스 내에서 진행 → MSA보다 훨씬 빠름
- 각 컴포넌트가 함수로 호출 → 성능에 제약 덜함, 운영 및 관리 용이

단점: 시스템이 점점 확장될 때. 큰 프로젝트일 때.

- 빌드/테스트 시간의 증가: 하나를 수정해도 시스템 전체를 빌드해야 함. → 유지보수 힘듦
- 작은 문제가 시스템 전체에 문제를 일으킴: 하나의 서비스 부분에 트래픽 문제로 서버가 다운되면, 모든 서비스 이용이 불가능할 것. 장애 원인 파악 어렵.
- 확장성에 불리 : 서비스 접속량 폭증 등의 이유로 하나의 서비스를 확장하기 위해 전체 프로젝트를 확장해야

### MSA (Micro Service Architecture)

기능(목적)별로 컴포넌트를 나누고 조합할 수 있도록 구축. 세분화됨.

각 컴포넌트는 API를 통해 다른 서비스와 통신함. 모든 서비스는 각각 독립된 서버로 운영하고 배포 → 서로 의존성이 없음.

장점:

- 장애: 하나의 서비스에 문제가 생겨도 다른 서비스에는 영향을 끼치지 않음.
  > 주문 서비스에 트래픽 증가 → 해당 서버만 확장해주면 됨.
- 확장: 서비스 별로 부분적인 확장이 가능.
- 배포: 서비스 별 개별 배포 가능. 배포 시 전체 서비스의 중단 없음.
- 각 서비스에 맞는 최적 기술을 선택 가능. 언어 제약 적음.

단점:

- 서비스 별로 호출할 때 API로 통신 → 속도가 느림.
- 서비스 별로 통신에 맞는 데이터로 맞추는 과정 필요.
- DB가 개별적으로 운영돼 트랜잭션으로 묶기 힘듦.

참고 링크

- [http://clipsoft.co.kr/wp/blog/마이크로서비스-아키텍처msa-개념](http://clipsoft.co.kr/wp/blog/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98msa-%EA%B0%9C%EB%85%90/)
- [https://velog.io/@tedigom/MSA-제대로-이해하기-1-MSA의-기본-개념-3sk28yrv0e](https://velog.io/@tedigom/MSA-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-1-MSA%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90-3sk28yrv0e)
